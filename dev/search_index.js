var documenterSearchIndex = {"docs":
[{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The Delaunay Tessellation Field Estimator (DTFE) and its extension to phase-space (PS-DTFE) are mathematical tool for the reconstruction of the density and velocity field of a discrete point set. We here review the derivations underlying these reconstruction methods.","category":"page"},{"location":"theory/#The-Delaunay-Tessellation-Field-Estimator","page":"Theory","title":"The Delaunay Tessellation Field Estimator","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Delaunay Tessellation Field Estimator (DTFE) is a mathematical tool for the reconstruction of the density and velocity field of a discrete point set developed by Willem Schaap and Rien van de Weijgaert (Schaap and Weijgaert 2004, Willem Schaap 2007). The DTFE method dynamically adapts to the variation of the density and geometry of the point set. The method is used in cosmological datasets (see for example the astronomy picture of the day, 7 November 2007) as it can simultaneously capture the geometry of the voids, walls, filaments and clusters and preserve the total mass of the pointset. The total mass is not preserved in the closely related  natural neighbor interpolation based on the Voronoi tessellation. For an efficient implementation of the DTFE method in c++ see the code by Marius Cautun.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Consider the pointset mathcalP consisting of N labaled points p_i in mathbbR^d, the velocity set mathcalV consisting of the N velocities v_i in mathbbR^d, and the mass set mathcalM consisting of the masses m_i in mathbbR corresponding to the points in mathcalP, with i=1dotsN. Using the points, we reconstruct the density field rhomathbbR^d to mathbbR. Using both the points and the velocities, we construct the velocity field vmathbbR^dto mathbbR.","category":"page"},{"location":"theory/#Density-reconstruction","page":"Theory","title":"Density reconstruction","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Given the pointset mathcalP, consider the Delaunay tesselation mathcalD consisting of N_T labelled simplices D_i, with i=1dots N_T. In two dimensions, a simplex is a triangle spanning three points in mathcalP. In three dimensions, a simplex is a tetrahedron spanning four points in mathcalP.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: A two-dimensional Delaunay tessellation with the circumscribed circles. The Delaunay tessellation has the property that no vertex is in the circumscribed circle of a triangle.)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let's assume we can associate a (to be determined) density estimate rho_i to each point in mathcalP. Given a symplex D in mathcalD spanned by the vertices p_l_0dots p_l_d in mathcalP, with the corresponding densities rho_l_0 dots rho_l_d, we construct a linear interpolation of the density field in the simplex ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"rho(x) = rho_l_0 + nabla rho (x-p_l_0)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"with x in D and the gradient vector nabla rhoin mathbbR^d associated to the simplex determined by the d linear consistency relations rho(p_l_i) = rho_l_i for i=1dotsd. In matrix notation,","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"nabla rho = \nbeginpmatrix\np_l_1-p_l_0\nvdots\np_l_d-p_l_0\nendpmatrix^-1\nbeginpmatrix\nrho_1-rho_0\nvdots\nrho_d-rho_0\nendpmatrix","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This system of equations is solvable when non of the points p_l_0 dots p_l_d are collinear. The integral over the linear interpolation yields","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"int_D rho(x)mathrmdx = fracV(D)d+1 sum_i in D rho_i ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"with V(D) the volume of the simplex D and i the labels of the vertices of D in mathcalP. Note that the volume of a simplex D spanned by p_l_0 dots p_l_d can be expressed as the determinant","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"V(D) = frac1d\nbeginvmatrix\np_l_1-p_l_0\nvdots\np_l_d-p_l_0\nendvmatrix","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The integral over density – assuming the density vanishes outside of the convex hull of the Delaunay tesselation – takes the form","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginalign\nint rho(x) mathrmdx \n= sum_i=1^N_T int_D_i rho(x)mathrmdx\n= frac1d+1 sum_i=1^N_T V(D_i) sum_j in D_i rho_j\nendalign","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where the first sum runs over the simplices of the tessellation and the second sum runs over the vertices of a given simplex. Note that rho_i enters the sum for each simplex for which it is a vertex. These simplices form the star W_i of the point p_i","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: The star of a vertex in a Delaunay tessellation)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Using this observation, we reorder the double sum, by collecting the terms involving rho_i leading to the terms rho_i(V(D_l_0) + dots + V(D_l_n)) = rho_i V(W_i), with the D_l_i's forming the star of p_i. The integral over the density is now a single sum over the points in mathcalP, i.e.,","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"int rho(x) mathrmdx =frac1d+1 sum_i=1^N rho_i V(W_i)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The key observation in DTFE is that when we chose the natural estimate of the density,","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"rho_i = frac(d+1) m_iV(W_i)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"by which the density at p_i only depends on the mass at the point and the local geometry, the integral over the density reduces to the total mass of the point set","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"int rho(x)mathrmdx = sum_i=1^N m_i","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"as one might expect of a density reconstruction method.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Now, given a point x in mathbbR^d, we can reconstruct the density field at this point by finding the simplex in which the point lays and evaluating the linear interpolation of the density in the simplex.","category":"page"},{"location":"theory/#Velocity-reconstruction","page":"Theory","title":"Velocity reconstruction","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The velocity field of the dataset can be analogously reconstructed reconstructed with an linear interpolation in the Delaunay cells. Given a simplex D spanned by the vertices p_l_0 dots p_l_d and the associated velocities v_l_0dotsv_l_d, we write the velocity field in the simplex D as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"v(x) = v_l_0 + nabla v (x - p_l_0)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"with the velocity gradient nabla v associated to the simplex determined by the linear consistency relations v(p_l_i) = v_l_i for i=1dotsd. In matrix notation,","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"nabla v = \nbeginpmatrix\np_l_1-p_l_0\nvdots\np_l_d-p_l_0\nendpmatrix^-1\nbeginpmatrix\nv_1-v_0\nvdots\nv_d-v_0\nendpmatrix","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Now, given a point x in mathbbR^d, we can reconstruct the velocity field at this point by finding the simplex in which the point lays and evaluating the corresponding linear interpolation in the simplex.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Note that the gradient nabla v is a piecewise constant function. Given the gradient nabla v for each simplex, it is natural to evaluate velocity deformation modes. In two dimensions, we evaluate the divergence theta and the curl omega defined by","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginalign\ntheta = nabla cdot v = fracpartial v_xpartial x + fracpartial v_ypartial y\nomega = fracpartial v_ypartial x - fracpartial v_xpartial y\nendalign","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"In three dimensions, we evaluate the divergence theta, the shear sigma_ij and the vorticity omega = epsilon^ijk omega_ij defined by","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginalign\ntheta = nabla cdot v = fracpartial v_xpartial x + fracpartial v_ypartial y + fracpartial v_zpartial z\nsigma_ij = frac12 leftfracpartial v_ipartial x_j + fracpartial v_jpartial x_iright - frac13 (nabla cdot v) delta_ij\nomega_ij =frac12 leftfracpartial v_ipartial x_j - fracpartial v_jpartial x_iright\nendalign","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"with the Kronecker delta delta_ij and the Levi-Civita symbol epsilon^ijk.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"For a point x in mathbbR^d, the reconstruction amounts to looking up the corresponding simplex and velocity deformation modes.","category":"page"},{"location":"theory/#The-Phase-Space-Delaunay-Tessellation-Field-Estimator","page":"Theory","title":"The Phase-Space Delaunay Tessellation Field Estimator","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The Phase-Space Delaunay Tessellation Field Estimator (PS-DTFE) extends the DTFE method to phase-space, inspired by work by [...]. For more details we refer to the publication Phase-Space Delaunay Tesselation Field Estimator. The evolution of our universe can be described in Lagrangian fluid dynamics in terms of the Lagrangian map x_t(q) = q + s_t(q) mapping a point in the space of initial conditions (Lagrangian space) to a point in the current universe (Eulerian space). The displacement field s_t(q) captures the displacement of a particle starting at q in time t. Given the Lagrangian map x_t, the density field is given by ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"rho(x) = sum_q in x_t^-1(x) fracrho_u nabla x_t(q) = sum_q in x_t^-1(x) fracrho_u I + nabla s_t(q)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The sum ranges over all points in Lagrangian space that can reach x in the given time. The DTFE method successfully estimates this density in single-stream regions. However, in multi-stream regions the Delaunay tessellation may identify particles as neighbours in Eulerian space that where far separated in Lagrangian space. To circumvent this problem, we evaluate the Delaunay tessellation of an early phase in our universe, where the universe was still in a single-stream state, and use this tessellation to estimate the density and velocity fields in Eulerian space. Finding which tetrahedra intersect a point is implemented with a Bounding Volume Hierarchy (BVH), a tree structure on a set of geometric objects.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#PhaseSpaceDTFE.SimBox","page":"Reference","title":"PhaseSpaceDTFE.SimBox","text":"SimBox(L, Ni)\n\nSets the size and resolution of the simulation box.\n\nExamples\n\njulia> SimBox(100, 64)\nSimBox(100.0, 64)\n\n\n\n\n\n","category":"type"},{"location":"#Phase-Space-DTFE","page":"Home","title":"Phase-Space DTFE","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PhaseSpaceDTFE.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Density field)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The PhaseSpaceDTFE package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/jfeldbrugge/PhaseSpaceDTFE.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or, equivalently, via the Pkg API:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"https://github.com/jfeldbrugge/PhaseSpaceDTFE.jl\")","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Given the initial (coordsq) and final configuration (coordsx) (and velocities (vels)) of N-body particles, we estimate the density/velocity/number of stream fields using the code ","category":"page"},{"location":"","page":"Home","title":"Home","text":"import PhaseSpaceDTFE\n\nm = 1.\ndepth = 5\nsim_box = SimBox(L, Ni)\n\nps_dtfe_sb = ps_dtfe_subbox(coords_q, coords_x, vels, m, depth, sim_box; N_target=32)\n\nRange = 0.:0.2:100.\ncoords_arr  = [[L/2., y, z] for y in Range, z in Range]\ndensity_field = density_subbox(coords_arr, ps_dtfe_sb)\nnumberOfStreams_field = numberOfStreams_subbox(coords_arr, ps_dtfe_sb)\nvelocitySum_field = velocitySum_subbox(coords_arr, ps_dtfe_sb)","category":"page"},{"location":"#Contributors","page":"Home","title":"Contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This code was written by:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Job Feldbrugge\nBenjamin Hertzsch","category":"page"},{"location":"","page":"Home","title":"Home","text":"We thank:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Bram Alferink","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we demonstrate the usage of the PhaseSpaceDTFE package to estimate the density and velocity fields from a GADGET-4 simulation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We start by importing the relevant libraries and loading the data.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using JLD2, Plots, HDF5, ProgressMeter, PhaseSpaceDTFE\n\n## set up simulation box\nNi = 64\nL  = 100.\nsim_box = SimBox(L, Ni)   ## need this for estimator creation\n\n## load data \nfunction load_data(file)\n    fid = h5open(file, \"r\")\n    pos = convert.(Float64, read(fid[\"PartType1\"][\"Coordinates\"]))\n    vel = convert.(Float64, read(fid[\"PartType1\"][\"Velocities\"]))\n    ids = read(fid[\"PartType1\"][\"ParticleIDs\"])\n    time = read_attribute(fid[\"Header\"], \"Time\")\n    close(fid)\n\n    ordering = sortperm(ids)\n    return (copy(pos[:,ordering]'), copy(vel[:,ordering]'), time)\nend\n\nfunction load_mass(file)\n    f = h5open(file, \"r\")\n    read_attribute(f[\"Header\"], \"MassTable\")[2]  # particle type 1\nend\n\nm = load_mass(\"../../test/data/snapshot_000.hdf5\")\n(coords_q, _, _) = load_data(\"../../test/data/snapshot_000.hdf5\")\n(coords_x, vels, _) = load_data(\"../../test/data/snapshot_002.hdf5\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The particle coordinates and velocities float matrices of size (N, 3). The particle mass m is a single float or a matrix of size (N, 3) for individual particle masses.","category":"page"},{"location":"tutorial/#Prequel:-Delaunay-Tesselation-Field-Estimator","page":"Tutorial","title":"Prequel: Delaunay Tesselation Field Estimator","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Before going though through PS-DTFE method, we demonstrate the density calculation with the traditional DTFE method by constructing the estimator only on the final (Eulerian) particle positions. For details, see examples below.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"## construct estimator\ndepth   = 5   # depth of estimator search tree\nps_dtfe = PS_DTFE_periodic(coords_x, coords_x, vels, m, depth, sim_box)\n\n# evaluate density field\nRange = 0:2.0:100.\ndensity_field = [PhaseSpaceDTFE.density([L/2., y, z], ps_dtfe) for y in Range, z in Range]\nheatmap(Range, Range, log10.(density_field), aspect_ratio=:equal, xlims=(0, L), ylims=(0, L), c=:grays, xlabel=\"[Mpc]\", ylabel=\"[Mpc]\")","category":"page"},{"location":"tutorial/#Phase-Space-Delaunay-Tessellation-Field-Estimator-—-basic-implementation","page":"Tutorial","title":"Phase-Space Delaunay Tessellation Field Estimator — basic implementation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We now demonstrate the use of the PS-DTFE method with the basic implementaiton suitable to simulations up to size 128^3 particles.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The first step is the construction of the estimator object from the initial (Lagrangian) and final (Eulerian) positions, coords_q and coords_x.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For the estimator construction, specify the box boundaries and the depth of the simplex search tree (technical details see https://academic.oup.com/mnras/article/536/1/807/7915986). Higher tree depths yield faster field evaluations, but require longer construction times. It is recommended to start with depth=5 and increase the depth if required for higher-resolution field evaluations.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The construction time should be of order 1-2 minutes for a 64^3 simulation at depth=7, or a 128^3 simulation at depth=5.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"## construct estimator\nps_dtfe = PS_DTFE_periodic(coords_q, coords_x, vels, m, depth, sim_box)\n\n## if want to ignore velocities\n#ps_dtfe = PS_DTFE(coords_q, coords_x, zeros(size(v_x)[1], 3), m, depth, box)\n\n# evaluate density field\ndensity_field = [PhaseSpaceDTFE.density([L/2., y, z], ps_dtfe) for y in Range, z in Range]\nheatmap(Range, Range, log10.(density_field), aspect_ratio=:equal, xlims=(0, L), ylims=(0, L), c=:grays, xlabel=\"[Mpc]\", ylabel=\"[Mpc]\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The corresponding number of streams field is evaluated as follows:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"nstreams_field = [numberOfStreams([L/2., y, z], ps_dtfe) for y in Range, z in Range]\nheatmap(Range, Range, nstreams_field, aspect_ratio=:equal, xlims=(0, L), ylims=(0, L), clim=(1, 7), xlabel=\"[Mpc]\", ylabel=\"[Mpc]\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly, the velocity field is evaluated with the velocity()-function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"vel_field = [velocity([L/2., y, z], ps_dtfe) for y in Range, z in Range]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In multistream regions, the velocity()-function returns the velocities of the individual streams (or NaN if single_stream=true is set in the function). To obtain the stream-mass weighted summation of the velocities, call the velocitySum()-function (reducing to velocity() in single-stream regions):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"vel_field = [velocitySum([L/2., y, z], ps_dtfe) for y in Range, z in Range]","category":"page"},{"location":"tutorial/#The-Phase-Space-Delaunay-Tessellation-Field-Estimator-—-subbox-implementation","page":"Tutorial","title":"The Phase-Space Delaunay Tessellation Field Estimator — subbox implementation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For the Phase-Space Delaunay Tessellation Field Estimator (PS-DTFE), use the same routine using both the initial and final positions and velocities of the N-body particles.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"## construct estimators with velocities\nps_dtfe_sb = ps_dtfe_subbox(coords_q, coords_x, vels, m, depth, sim_box; N_target=32)\n\n## construct estimator without velocities\n# ps_dtfe_sb = ps_dtfe_subbox(coords_q, coords_x, m, depth, sim_box; N_target=32)\n\n## it is recommended to save the estimator object (holding the subbox references) for further use\nsave(\"ps_dtfe_sb.jld2\", \"ps-dtfe-sb\", ps_dtfe_sb)\nps_dtfe_sb = load(\"ps_dtfe_sb.jld2\")[\"ps-dtfe-sb\"]\nnothing","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We evaluate the density field ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"\ncoords_arr = [[L/2., y, z] for y in Range, z in Range]\ndensity_field = density_subbox(coords_arr, ps_dtfe_sb)\nheatmap(Range, Range, log10.(density_field), aspect_ratio=:equal, xlims=(0, L), ylims=(0, L), c=:grays, xlabel=\"[Mpc]\", ylabel=\"[Mpc]\") ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"the number of streams","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"number_field = numberOfStreams_subbox(coords_arr, ps_dtfe_sb)\nheatmap(Range, Range, log10.(number_field), aspect_ratio=:equal, xlims=(0, L), ylims=(0, L), xlabel=\"[Mpc]\", ylabel=\"[Mpc]\") ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and the mass weighted velocity field","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"velocitySum_field = velocitySum_subbox(coords_arr, ps_dtfe_sb)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Clear temporary files","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rm(\"ps_dtfe\", recursive=true)\nrm(\"ps_dtfe_sb.jld2\")","category":"page"}]
}
